/**
 * Tencent is pleased to support the open source community by making Tars available.
 *
 * Copyright (C) 2016THL A29 Limited, a Tencent company. All rights reserved.
 *
 * Licensed under the BSD 3-Clause License (the "License"); you may not use this file except 
 * in compliance with the License. You may obtain a copy of the License at
 *
 * https://opensource.org/licenses/BSD-3-Clause
 *
 * Unless required by applicable law or agreed to in writing, software distributed 
 * under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR 
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the 
 * specific language governing permissions and limitations under the License.
 */

#include "code_generator.h"

/**
 * @brief 生成头部信息
 * 
 * @param sTypeName 转换模式
 * @return string 
 */
string CodeGenerator::printHeaderRemark(const string &sTypeName)
{
    ostringstream s;
    s << "// **********************************************************************" << endl;
    s << "// Parsed By " << IDL_NAMESPACE_STR << "Parser(" << PARSER_VERSION << "), Generated By " << EXECUTE_FILENAME << "(" << GENERATOR_VERSION << ")" << endl;
    s << "// " << IDL_NAMESPACE_STR << "Parser Maintained By <" << TC_Common::upper(IDL_NAMESPACE_STR) << "> and " << EXECUTE_FILENAME << " Maintained By <superzheng>" << endl;
    s << "// Generated from \"" << TC_File::extractFileName(_sIdlFile) << "\" by " <<
            (_bEntry ? sTypeName : (_bMinimalMembers ? "Minimal" : "Relation")) << " Mode" << endl;
    s << "// **********************************************************************" << endl;
    s << endl;

    return s.str();
}

/**
 * @brief 生成文件，总入口
 * 
 * @param file 输入文件
 * @param bEntry 是否入口
 */
void CodeGenerator::createFile(const string &file, const bool bEntry)
{
    //获取文件全路径
    _sIdlFile = getRealFileInfo(file);
    _bEntry = bEntry;
    // 基于 flex、bison 实现 的词法、文法 解析。 TODO：貌似没看到原始的 词法/文法 定义文件？
    g_parse->parse(_sIdlFile);
    // 获取所有的 context
    vector<ContextPtr> contexts = g_parse->getContexts();

    for(size_t i = 0; i < contexts.size(); i++)
    {
        if (_sIdlFile == contexts[i]->getFileName())
        {
            // 遍历context，填充 _mapFiles
            scan(_sIdlFile, true);                                  // collect idl symbols
            // 转换为  XXXXTars.js ，无 proxy 和 imp 代码
            if (!_bClient && !_bServer)
            {
                if (_bTS)
                {
                    generateTS(contexts[i]);                        // generate .ts
                }
                else
                {
                    generateJS(contexts[i]);                        // generate .js
                    if (_bDTS) generateDTS(contexts[i]);            // generate .d.ts
                }
            }
            // 转换客户端代码  XXXProxy.js
            if (_bClient)
            {
                //生成客户端时，需要为所有的 interface 添加 tars_ping 调用支持
                addTarsPingForProxy(contexts[i]);
                if (_bTS)
                {
                    if (!generateTSProxy(contexts[i])) return;      // generate .ts for proxy classes
                }
                else
                {
                    if (!generateJSProxy(contexts[i])) return;      // generate .js for proxy classes
                    if (_bDTS) generateDTSProxy(contexts[i]);       // generate .d.ts for proxy classes
                }
            }
            // 转换服务端代码 XXXX.js 和 XXXImp.js
            if (_bServer)
            {
                if (_bTS)
                {
                    if (!generateTSServer(contexts[i])) return;      // generate .ts for server classes
                    generateTSServerImp(contexts[i]);                // generate .ts for server implementations
                }
                else
                {
                    if (!generateJSServer(contexts[i])) return;      // generate .js for server classes
                    if (_bDTS) generateDTSServer(contexts[i]);       // generate .d.ts for server classes
                    generateJSServerImp(contexts[i]);                // generate .js for server implementations
                }
            }
            // 获取协议的依赖文件，递归转换
            vector<string> files = contexts[i]->getIncludes();
            for (size_t ii = 0; _bRecursive && ii < files.size(); ii++)
            {
                CodeGenerator node;
                node.setRpcPath(_sRpcPath);
                node.setStreamPath(_sStreamPath);
                node.setTargetPath(_sToPath);
                node.setRecursive(_bRecursive);
                node.setUseSpecialPath(_bUseSpecialPath);
                node.setLongType(_iLongType);
                node.setStringBinaryEncoding(_bStringBinaryEncoding);
                node.setMinimalMembers(_bMinimalMembers);
                node.setDependent(_depMembers);
                node.setEnableTS(_bTS);
                node.setEnableDTS(_bDTS);

                node.createFile(files[ii], false);
            }
        }
    }
}

void CodeGenerator::addTarsPingForProxy(const ContextPtr &cPtr){
    vector<NamespacePtr> namespaces = cPtr->getNamespaces();
    string ping = TC_Common::lower(IDL_NAMESPACE_STR) + "_ping";
    for(size_t i = 0; i < namespaces.size(); i++)
    {
        vector<InterfacePtr> & is = namespaces[i]->getAllInterfacePtr();
        for (size_t ii = 0; ii < is.size(); ii++)
        {
            is[ii]->createOperation(ping, nullptr);
        }
    }
}